// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "atccm.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * from https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto
 *
 * @generated from protobuf message Timestamp
 */
export interface Timestamp {
    /**
     * @generated from protobuf field: int64 seconds = 1;
     */
    seconds: bigint;
    /**
     * @generated from protobuf field: int32 nanos = 2;
     */
    nanos: number;
}
/**
 * @generated from protobuf message ChargerStatus
 */
export interface ChargerStatus {
    /**
     * @generated from protobuf field: ChargeStatus status = 1;
     */
    status: ChargeStatus;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: double battery_voltage = 3;
     */
    batteryVoltage: number; // Resolution: 0.01V, Range 0..655.35 V
    /**
     * @generated from protobuf field: double output_current = 4;
     */
    outputCurrent: number; // Resolution: 0.01A, Range: 0..655.35 A
    /**
     * @generated from protobuf field: double external_probe_temperature = 5;
     */
    externalProbeTemperature: number; // Resolution: 0.1C, Range: -3276,7…3276,7 °C (-3276,8°C = 0x8000 is probe 1 H not connected)
    /**
     * @generated from protobuf field: EventSource id = 15;
     */
    id: EventSource;
}
/**
 * @generated from protobuf message MotorStatus
 */
export interface MotorStatus {
    /**
     * @generated from protobuf field: int32 rpm = 1;
     */
    rpm: number;
    /**
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
    /**
     * @generated from protobuf field: double current = 3;
     */
    current: number;
    /**
     * @generated from protobuf field: double controller_temperature = 4;
     */
    controllerTemperature: number;
    /**
     * @generated from protobuf field: double motor_temperature = 5;
     */
    motorTemperature: number;
    /**
     * @generated from protobuf field: int32 throttle = 6;
     */
    throttle: number;
    /**
     * @generated from protobuf field: uint32 error_code = 7;
     */
    errorCode: number;
    /**
     * @generated from protobuf field: double battery_voltage = 8;
     */
    batteryVoltage: number;
    /**
     * @generated from protobuf field: EventSource id = 15;
     */
    id: EventSource;
}
/**
 * @generated from protobuf message Versions
 */
export interface Versions {
    /**
     * @generated from protobuf field: string software_version = 1;
     */
    softwareVersion: string;
    /**
     * @generated from protobuf field: string bootloader_version = 2;
     */
    bootloaderVersion: string;
}
/**
 * @generated from protobuf message TelemetryMsg
 */
export interface TelemetryMsg {
    /**
     * @generated from protobuf field: SystemState systemState = 1;
     */
    systemState: SystemState;
    /**
     * @generated from protobuf field: repeated MotorStatus motors = 2;
     */
    motors: MotorStatus[];
    /**
     * @generated from protobuf field: repeated ChargerStatus chargers = 3;
     */
    chargers: ChargerStatus[];
}
/**
 * @generated from protobuf message ErrorMsg
 */
export interface ErrorMsg {
    /**
     * @generated from protobuf field: EventSource source = 1;
     */
    source: EventSource;
    /**
     * @generated from protobuf field: uint32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string text = 3;
     */
    text: string;
}
/**
 * @generated from protobuf message EventMsg
 */
export interface EventMsg {
    /**
     * @generated from protobuf field: Timestamp timestamp = 1;
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "telemetry";
        /**
         * @generated from protobuf field: TelemetryMsg telemetry = 2;
         */
        telemetry: TelemetryMsg;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: ErrorMsg error = 3;
         */
        error: ErrorMsg;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message EventQueueLeftResponse
 */
export interface EventQueueLeftResponse {
    /**
     * @generated from protobuf field: uint32 eventsLeftInTheQueue = 1;
     */
    eventsLeftInTheQueue: number;
}
/**
 * @generated from protobuf message RemoteControlCommand
 */
export interface RemoteControlCommand {
    /**
     * @generated from protobuf field: int32 handle = 1;
     */
    handle: number;
    /**
     * @generated from protobuf field: bool fwd_button = 2;
     */
    fwdButton: boolean;
    /**
     * @generated from protobuf field: bool bwd_button = 3;
     */
    bwdButton: boolean;
    /**
     * @generated from protobuf field: bool errors_disabled = 4;
     */
    errorsDisabled: boolean;
}
/**
 * @generated from protobuf message AtccmStatus
 */
export interface AtccmStatus {
    /**
     * @generated from protobuf field: UiMode mode = 1;
     */
    mode: UiMode;
    /**
     * @generated from protobuf field: bool termination_enabled = 2;
     */
    terminationEnabled: boolean;
    /**
     * @generated from protobuf field: bool charger_enabled = 3;
     */
    chargerEnabled: boolean;
    /**
     * @generated from protobuf field: bool retraction_enabled = 9;
     */
    retractionEnabled: boolean;
    /**
     * @generated from protobuf field: bool jet_mode_enabled = 10;
     */
    jetModeEnabled: boolean;
    /**
     * @generated from protobuf field: uint32 thruster_position = 8;
     */
    thrusterPosition: number;
    /**
     * @generated from protobuf field: MotorStatus motor_status = 5;
     */
    motorStatus?: MotorStatus;
    /**
     * @generated from protobuf field: ChargerStatus charger_status = 6;
     */
    chargerStatus?: ChargerStatus;
    /**
     * @generated from protobuf field: Versions versions = 7;
     */
    versions?: Versions;
}
/**
 * @generated from protobuf message Values
 */
export interface Values {
    /**
     * @generated from protobuf field: bool termination_enabled = 1;
     */
    terminationEnabled: boolean;
    /**
     * @generated from protobuf field: bool charger_on = 2;
     */
    chargerOn: boolean;
    /**
     * @generated from protobuf field: uint32 blinks = 3;
     */
    blinks: number;
    /**
     * @generated from protobuf field: uint32 thruster_position = 4;
     */
    thrusterPosition: number;
    /**
     * @generated from protobuf field: bool retraction_enabled = 5;
     */
    retractionEnabled: boolean;
    /**
     * @generated from protobuf field: bool jet_mode_enabled = 6;
     */
    jetModeEnabled: boolean;
}
/**
 * @generated from protobuf message Configuration
 */
export interface Configuration {
    /**
     * @generated from protobuf field: bool termination_enabled = 1;
     */
    terminationEnabled: boolean;
    /**
     * @generated from protobuf field: bool charger_enabled = 2;
     */
    chargerEnabled: boolean;
    /**
     * @generated from protobuf field: uint32 thruster_position = 3;
     */
    thrusterPosition: number;
    /**
     * @generated from protobuf field: bool retraction_enabled = 4;
     */
    retractionEnabled: boolean;
    /**
     * @generated from protobuf field: bool jet_mode_enabled = 5;
     */
    jetModeEnabled: boolean;
    /**
     * @generated from protobuf field: bool inactivityShutdownEnabled = 6;
     */
    inactivityShutdownEnabled: boolean;
    /**
     * @generated from protobuf field: uint32 inactivityShutdownTimeoutIsSeconds = 7;
     */
    inactivityShutdownTimeoutIsSeconds: number;
}
/**
 * Main packet that is exchanged between the ATCCM and the UI. Goes both directions
 *
 * @generated from protobuf message AtccmPacket
 */
export interface AtccmPacket {
    /**
     * @generated from protobuf field: uint32 protocol_version = 1;
     */
    protocolVersion: number;
    /**
     * @generated from protobuf field: Command command = 2;
     */
    command: Command;
    /**
     * @generated from protobuf field: bool write = 3;
     */
    write: boolean; // If true, the packet is sent from the UI to the ATCCM
    /**
     * @generated from protobuf field: AtccmStatus status = 4;
     */
    status?: AtccmStatus; // Only valid from ATCCM to UI
    /**
     * @generated from protobuf field: Values values = 5;
     */
    values?: Values; // Only valid from UI to ATCCM
    /**
     * @generated from protobuf field: Configuration configuration = 6;
     */
    configuration?: Configuration;
}
/**
 * These are all the "commands" that can be sent from the UI to the ATCCM and back
 * The ATCCM will send the STATUS command periodically on its own
 *
 * @generated from protobuf enum Command
 */
export enum Command {
    /**
     * Protobuf enums need to start at 0
     *
     * @generated from protobuf enum value: NOOP = 0;
     */
    NOOP = 0,
    /**
     * Typically sent periodically
     *
     * @generated from protobuf enum value: STATUS = 1;
     */
    STATUS = 1,
    /**
     * Blink command
     *
     * @generated from protobuf enum value: BLINK = 2;
     */
    BLINK = 2,
    /**
     * Termination
     *
     * @generated from protobuf enum value: TERMINATION = 3;
     */
    TERMINATION = 3,
    /**
     * Enable charger
     *
     * @generated from protobuf enum value: CHARGER_ON = 4;
     */
    CHARGER_ON = 4,
    /**
     * Reads SW and FW versions
     *
     * @generated from protobuf enum value: VERSION = 5;
     */
    VERSION = 5,
    /**
     * Changes the thruster position
     *
     * @generated from protobuf enum value: THRUSTER_POSITION = 6;
     */
    THRUSTER_POSITION = 6,
    /**
     * Reads the event log size
     *
     * @generated from protobuf enum value: READ_EVENT_LOG_SIZE = 7;
     */
    READ_EVENT_LOG_SIZE = 7,
    /**
     * Reads the next event on the event log
     *
     * @generated from protobuf enum value: READ_NEXT_EVENT_FROM_LOG = 8;
     */
    READ_NEXT_EVENT_FROM_LOG = 8,
    /**
     * Clears the error state of the joystick
     *
     * @generated from protobuf enum value: CLEAR_ERRORS = 9;
     */
    CLEAR_ERRORS = 9,
    /**
     * Enables or disables thruster retraction on power on/off
     *
     * @generated from protobuf enum value: RETRACTION_ENABLED = 10;
     */
    RETRACTION_ENABLED = 10,
    /**
     * Enables or disables jet mode
     *
     * @generated from protobuf enum value: JET_MODE_ENABLED = 11;
     */
    JET_MODE_ENABLED = 11,
    /**
     * Reads the configuration (expects response with Configuration)
     *
     * @generated from protobuf enum value: READ_CONFIGURATION = 12;
     */
    READ_CONFIGURATION = 12,
    /**
     * Writes the configuration
     *
     * @generated from protobuf enum value: WRITE_CONFIGURATION = 13;
     */
    WRITE_CONFIGURATION = 13
}
/**
 * @generated from protobuf enum SystemState
 */
export enum SystemState {
    /**
     * @generated from protobuf enum value: STATE_UNSPECIFIED = 0;
     */
    STATE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STATE_INITIALIZING = 1;
     */
    STATE_INITIALIZING = 1,
    /**
     * @generated from protobuf enum value: STATE_OPERATIONAL = 2;
     */
    STATE_OPERATIONAL = 2,
    /**
     * @generated from protobuf enum value: STATE_PRESLEEP = 3;
     */
    STATE_PRESLEEP = 3,
    /**
     * @generated from protobuf enum value: STATE_SLEEP = 4;
     */
    STATE_SLEEP = 4,
    /**
     * @generated from protobuf enum value: STATE_ERROR = 15;
     */
    STATE_ERROR = 15
}
/**
 * @generated from protobuf enum EventSource
 */
export enum EventSource {
    /**
     * @generated from protobuf enum value: SRC_UNSPECIFIED = 0;
     */
    SRC_UNSPECIFIED = 0,
    /**
     * Single-joystick event sources
     *
     * Master/Current ATCCM
     *
     * @generated from protobuf enum value: SRC_ATCCM = 1;
     */
    SRC_ATCCM = 1,
    /**
     * Current Motor
     *
     * @generated from protobuf enum value: SRC_MOTOR = 2;
     */
    SRC_MOTOR = 2,
    /**
     * Current Charger
     *
     * @generated from protobuf enum value: SRC_CHARGER = 3;
     */
    SRC_CHARGER = 3,
    /**
     * Auxiliary ATCCM 1
     *
     * @generated from protobuf enum value: SRC_ATCCM_1 = 10;
     */
    SRC_ATCCM_1 = 10,
    /**
     * Auxiliary Motor 1
     *
     * @generated from protobuf enum value: SRC_MOTOR_1 = 11;
     */
    SRC_MOTOR_1 = 11,
    /**
     * Auxiliary Charger 1
     *
     * @generated from protobuf enum value: SRC_CHARGER_1 = 12;
     */
    SRC_CHARGER_1 = 12,
    /**
     * Auxiliary ATCCM 2
     *
     * @generated from protobuf enum value: SRC_ATCCM_2 = 20;
     */
    SRC_ATCCM_2 = 20,
    /**
     * Auxiliary Motor 2
     *
     * @generated from protobuf enum value: SRC_MOTOR_2 = 21;
     */
    SRC_MOTOR_2 = 21,
    /**
     * Auxiliary Charger 2
     *
     * @generated from protobuf enum value: SRC_CHARGER_2 = 22;
     */
    SRC_CHARGER_2 = 22,
    /**
     * Auxiliary ATCCM 3
     *
     * @generated from protobuf enum value: SRC_ATCCM_3 = 30;
     */
    SRC_ATCCM_3 = 30,
    /**
     * Auxiliary Motor 3
     *
     * @generated from protobuf enum value: SRC_MOTOR_3 = 31;
     */
    SRC_MOTOR_3 = 31,
    /**
     * Auxiliary Charger 3
     *
     * @generated from protobuf enum value: SRC_CHARGER_3 = 32;
     */
    SRC_CHARGER_3 = 32
}
/**
 * @generated from protobuf enum ChargeStatus
 */
export enum ChargeStatus {
    /**
     * @generated from protobuf enum value: STOP = 0;
     */
    STOP = 0,
    /**
     * @generated from protobuf enum value: RESET = 1;
     */
    RESET = 1,
    /**
     * @generated from protobuf enum value: SOFT_START = 2;
     */
    SOFT_START = 2,
    /**
     * @generated from protobuf enum value: SEARCH_PHASE = 3;
     */
    SEARCH_PHASE = 3,
    /**
     * @generated from protobuf enum value: BOOST = 4;
     */
    BOOST = 4,
    /**
     * @generated from protobuf enum value: ABSORPTION = 5;
     */
    ABSORPTION = 5,
    /**
     * @generated from protobuf enum value: FLOATING = 6;
     */
    FLOATING = 6,
    /**
     * @generated from protobuf enum value: EGALISATION = 7;
     */
    EGALISATION = 7,
    /**
     * @generated from protobuf enum value: DESULFATATION = 8;
     */
    DESULFATATION = 8,
    /**
     * @generated from protobuf enum value: CONTROL_UI = 9;
     */
    CONTROL_UI = 9,
    /**
     * @generated from protobuf enum value: UNKNOWN = 255;
     */
    UNKNOWN = 255
}
/**
 * @generated from protobuf enum UiMode
 */
export enum UiMode {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * If a CHARGER_Frame1, Byte 5, Charge status is different from 4 to 9
     *
     * @generated from protobuf enum value: MOTOR = 1;
     */
    MOTOR = 1,
    /**
     * If a CHARGER_Frame1, Byte 5, Charge status is between 4 and 9 AND no throttle is applied for 2 s
     *
     * @generated from protobuf enum value: CHARGE_NO_THROTTLE = 2;
     */
    CHARGE_NO_THROTTLE = 2,
    /**
     * If a CHARGER_Frame1, Byte 5, Charge status is between 4 and 9 AND throttle is applied
     *
     * @generated from protobuf enum value: CHARGE_THROTTLE = 3;
     */
    CHARGE_THROTTLE = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Timestamp$Type extends MessageType<Timestamp> {
    constructor() {
        super("Timestamp", [
            { no: 1, name: "seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "nanos", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Timestamp>): Timestamp {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seconds = 0n;
        message.nanos = 0;
        if (value !== undefined)
            reflectionMergePartial<Timestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Timestamp): Timestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 seconds */ 1:
                    message.seconds = reader.int64().toBigInt();
                    break;
                case /* int32 nanos */ 2:
                    message.nanos = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 seconds = 1; */
        if (message.seconds !== 0n)
            writer.tag(1, WireType.Varint).int64(message.seconds);
        /* int32 nanos = 2; */
        if (message.nanos !== 0)
            writer.tag(2, WireType.Varint).int32(message.nanos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Timestamp
 */
export const Timestamp = new Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChargerStatus$Type extends MessageType<ChargerStatus> {
    constructor() {
        super("ChargerStatus", [
            { no: 1, name: "status", kind: "enum", T: () => ["ChargeStatus", ChargeStatus] },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "battery_voltage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "output_current", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "external_probe_temperature", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "id", kind: "enum", T: () => ["EventSource", EventSource] }
        ]);
    }
    create(value?: PartialMessage<ChargerStatus>): ChargerStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.enabled = false;
        message.batteryVoltage = 0;
        message.outputCurrent = 0;
        message.externalProbeTemperature = 0;
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<ChargerStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChargerStatus): ChargerStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ChargeStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* double battery_voltage */ 3:
                    message.batteryVoltage = reader.double();
                    break;
                case /* double output_current */ 4:
                    message.outputCurrent = reader.double();
                    break;
                case /* double external_probe_temperature */ 5:
                    message.externalProbeTemperature = reader.double();
                    break;
                case /* EventSource id */ 15:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChargerStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ChargeStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        /* double battery_voltage = 3; */
        if (message.batteryVoltage !== 0)
            writer.tag(3, WireType.Bit64).double(message.batteryVoltage);
        /* double output_current = 4; */
        if (message.outputCurrent !== 0)
            writer.tag(4, WireType.Bit64).double(message.outputCurrent);
        /* double external_probe_temperature = 5; */
        if (message.externalProbeTemperature !== 0)
            writer.tag(5, WireType.Bit64).double(message.externalProbeTemperature);
        /* EventSource id = 15; */
        if (message.id !== 0)
            writer.tag(15, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChargerStatus
 */
export const ChargerStatus = new ChargerStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MotorStatus$Type extends MessageType<MotorStatus> {
    constructor() {
        super("MotorStatus", [
            { no: 1, name: "rpm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "current", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "controller_temperature", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "motor_temperature", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "throttle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "error_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "battery_voltage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "id", kind: "enum", T: () => ["EventSource", EventSource] }
        ]);
    }
    create(value?: PartialMessage<MotorStatus>): MotorStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rpm = 0;
        message.enabled = false;
        message.current = 0;
        message.controllerTemperature = 0;
        message.motorTemperature = 0;
        message.throttle = 0;
        message.errorCode = 0;
        message.batteryVoltage = 0;
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<MotorStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MotorStatus): MotorStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 rpm */ 1:
                    message.rpm = reader.int32();
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* double current */ 3:
                    message.current = reader.double();
                    break;
                case /* double controller_temperature */ 4:
                    message.controllerTemperature = reader.double();
                    break;
                case /* double motor_temperature */ 5:
                    message.motorTemperature = reader.double();
                    break;
                case /* int32 throttle */ 6:
                    message.throttle = reader.int32();
                    break;
                case /* uint32 error_code */ 7:
                    message.errorCode = reader.uint32();
                    break;
                case /* double battery_voltage */ 8:
                    message.batteryVoltage = reader.double();
                    break;
                case /* EventSource id */ 15:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MotorStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 rpm = 1; */
        if (message.rpm !== 0)
            writer.tag(1, WireType.Varint).int32(message.rpm);
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        /* double current = 3; */
        if (message.current !== 0)
            writer.tag(3, WireType.Bit64).double(message.current);
        /* double controller_temperature = 4; */
        if (message.controllerTemperature !== 0)
            writer.tag(4, WireType.Bit64).double(message.controllerTemperature);
        /* double motor_temperature = 5; */
        if (message.motorTemperature !== 0)
            writer.tag(5, WireType.Bit64).double(message.motorTemperature);
        /* int32 throttle = 6; */
        if (message.throttle !== 0)
            writer.tag(6, WireType.Varint).int32(message.throttle);
        /* uint32 error_code = 7; */
        if (message.errorCode !== 0)
            writer.tag(7, WireType.Varint).uint32(message.errorCode);
        /* double battery_voltage = 8; */
        if (message.batteryVoltage !== 0)
            writer.tag(8, WireType.Bit64).double(message.batteryVoltage);
        /* EventSource id = 15; */
        if (message.id !== 0)
            writer.tag(15, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MotorStatus
 */
export const MotorStatus = new MotorStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Versions$Type extends MessageType<Versions> {
    constructor() {
        super("Versions", [
            { no: 1, name: "software_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bootloader_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Versions>): Versions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.softwareVersion = "";
        message.bootloaderVersion = "";
        if (value !== undefined)
            reflectionMergePartial<Versions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Versions): Versions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string software_version */ 1:
                    message.softwareVersion = reader.string();
                    break;
                case /* string bootloader_version */ 2:
                    message.bootloaderVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Versions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string software_version = 1; */
        if (message.softwareVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.softwareVersion);
        /* string bootloader_version = 2; */
        if (message.bootloaderVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.bootloaderVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Versions
 */
export const Versions = new Versions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelemetryMsg$Type extends MessageType<TelemetryMsg> {
    constructor() {
        super("TelemetryMsg", [
            { no: 1, name: "systemState", kind: "enum", T: () => ["SystemState", SystemState] },
            { no: 2, name: "motors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MotorStatus },
            { no: 3, name: "chargers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ChargerStatus }
        ]);
    }
    create(value?: PartialMessage<TelemetryMsg>): TelemetryMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.systemState = 0;
        message.motors = [];
        message.chargers = [];
        if (value !== undefined)
            reflectionMergePartial<TelemetryMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelemetryMsg): TelemetryMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SystemState systemState */ 1:
                    message.systemState = reader.int32();
                    break;
                case /* repeated MotorStatus motors */ 2:
                    message.motors.push(MotorStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ChargerStatus chargers */ 3:
                    message.chargers.push(ChargerStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelemetryMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SystemState systemState = 1; */
        if (message.systemState !== 0)
            writer.tag(1, WireType.Varint).int32(message.systemState);
        /* repeated MotorStatus motors = 2; */
        for (let i = 0; i < message.motors.length; i++)
            MotorStatus.internalBinaryWrite(message.motors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ChargerStatus chargers = 3; */
        for (let i = 0; i < message.chargers.length; i++)
            ChargerStatus.internalBinaryWrite(message.chargers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TelemetryMsg
 */
export const TelemetryMsg = new TelemetryMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorMsg$Type extends MessageType<ErrorMsg> {
    constructor() {
        super("ErrorMsg", [
            { no: 1, name: "source", kind: "enum", T: () => ["EventSource", EventSource] },
            { no: 2, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorMsg>): ErrorMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = 0;
        message.code = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<ErrorMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorMsg): ErrorMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventSource source */ 1:
                    message.source = reader.int32();
                    break;
                case /* uint32 code */ 2:
                    message.code = reader.uint32();
                    break;
                case /* string text */ 3:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventSource source = 1; */
        if (message.source !== 0)
            writer.tag(1, WireType.Varint).int32(message.source);
        /* uint32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).uint32(message.code);
        /* string text = 3; */
        if (message.text !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ErrorMsg
 */
export const ErrorMsg = new ErrorMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventMsg$Type extends MessageType<EventMsg> {
    constructor() {
        super("EventMsg", [
            { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 2, name: "telemetry", kind: "message", oneof: "event", T: () => TelemetryMsg },
            { no: 3, name: "error", kind: "message", oneof: "event", T: () => ErrorMsg }
        ]);
    }
    create(value?: PartialMessage<EventMsg>): EventMsg {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<EventMsg>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventMsg): EventMsg {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Timestamp timestamp */ 1:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* TelemetryMsg telemetry */ 2:
                    message.event = {
                        oneofKind: "telemetry",
                        telemetry: TelemetryMsg.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).telemetry)
                    };
                    break;
                case /* ErrorMsg error */ 3:
                    message.event = {
                        oneofKind: "error",
                        error: ErrorMsg.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventMsg, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Timestamp timestamp = 1; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* TelemetryMsg telemetry = 2; */
        if (message.event.oneofKind === "telemetry")
            TelemetryMsg.internalBinaryWrite(message.event.telemetry, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ErrorMsg error = 3; */
        if (message.event.oneofKind === "error")
            ErrorMsg.internalBinaryWrite(message.event.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EventMsg
 */
export const EventMsg = new EventMsg$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventQueueLeftResponse$Type extends MessageType<EventQueueLeftResponse> {
    constructor() {
        super("EventQueueLeftResponse", [
            { no: 1, name: "eventsLeftInTheQueue", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EventQueueLeftResponse>): EventQueueLeftResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventsLeftInTheQueue = 0;
        if (value !== undefined)
            reflectionMergePartial<EventQueueLeftResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventQueueLeftResponse): EventQueueLeftResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 eventsLeftInTheQueue */ 1:
                    message.eventsLeftInTheQueue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventQueueLeftResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 eventsLeftInTheQueue = 1; */
        if (message.eventsLeftInTheQueue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.eventsLeftInTheQueue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EventQueueLeftResponse
 */
export const EventQueueLeftResponse = new EventQueueLeftResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteControlCommand$Type extends MessageType<RemoteControlCommand> {
    constructor() {
        super("RemoteControlCommand", [
            { no: 1, name: "handle", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fwd_button", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "bwd_button", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "errors_disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RemoteControlCommand>): RemoteControlCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.handle = 0;
        message.fwdButton = false;
        message.bwdButton = false;
        message.errorsDisabled = false;
        if (value !== undefined)
            reflectionMergePartial<RemoteControlCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteControlCommand): RemoteControlCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 handle */ 1:
                    message.handle = reader.int32();
                    break;
                case /* bool fwd_button */ 2:
                    message.fwdButton = reader.bool();
                    break;
                case /* bool bwd_button */ 3:
                    message.bwdButton = reader.bool();
                    break;
                case /* bool errors_disabled */ 4:
                    message.errorsDisabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoteControlCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 handle = 1; */
        if (message.handle !== 0)
            writer.tag(1, WireType.Varint).int32(message.handle);
        /* bool fwd_button = 2; */
        if (message.fwdButton !== false)
            writer.tag(2, WireType.Varint).bool(message.fwdButton);
        /* bool bwd_button = 3; */
        if (message.bwdButton !== false)
            writer.tag(3, WireType.Varint).bool(message.bwdButton);
        /* bool errors_disabled = 4; */
        if (message.errorsDisabled !== false)
            writer.tag(4, WireType.Varint).bool(message.errorsDisabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RemoteControlCommand
 */
export const RemoteControlCommand = new RemoteControlCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AtccmStatus$Type extends MessageType<AtccmStatus> {
    constructor() {
        super("AtccmStatus", [
            { no: 1, name: "mode", kind: "enum", T: () => ["UiMode", UiMode] },
            { no: 2, name: "termination_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "charger_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "retraction_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "jet_mode_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "thruster_position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "motor_status", kind: "message", T: () => MotorStatus },
            { no: 6, name: "charger_status", kind: "message", T: () => ChargerStatus },
            { no: 7, name: "versions", kind: "message", T: () => Versions }
        ]);
    }
    create(value?: PartialMessage<AtccmStatus>): AtccmStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        message.terminationEnabled = false;
        message.chargerEnabled = false;
        message.retractionEnabled = false;
        message.jetModeEnabled = false;
        message.thrusterPosition = 0;
        if (value !== undefined)
            reflectionMergePartial<AtccmStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AtccmStatus): AtccmStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UiMode mode */ 1:
                    message.mode = reader.int32();
                    break;
                case /* bool termination_enabled */ 2:
                    message.terminationEnabled = reader.bool();
                    break;
                case /* bool charger_enabled */ 3:
                    message.chargerEnabled = reader.bool();
                    break;
                case /* bool retraction_enabled */ 9:
                    message.retractionEnabled = reader.bool();
                    break;
                case /* bool jet_mode_enabled */ 10:
                    message.jetModeEnabled = reader.bool();
                    break;
                case /* uint32 thruster_position */ 8:
                    message.thrusterPosition = reader.uint32();
                    break;
                case /* MotorStatus motor_status */ 5:
                    message.motorStatus = MotorStatus.internalBinaryRead(reader, reader.uint32(), options, message.motorStatus);
                    break;
                case /* ChargerStatus charger_status */ 6:
                    message.chargerStatus = ChargerStatus.internalBinaryRead(reader, reader.uint32(), options, message.chargerStatus);
                    break;
                case /* Versions versions */ 7:
                    message.versions = Versions.internalBinaryRead(reader, reader.uint32(), options, message.versions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AtccmStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UiMode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        /* bool termination_enabled = 2; */
        if (message.terminationEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.terminationEnabled);
        /* bool charger_enabled = 3; */
        if (message.chargerEnabled !== false)
            writer.tag(3, WireType.Varint).bool(message.chargerEnabled);
        /* bool retraction_enabled = 9; */
        if (message.retractionEnabled !== false)
            writer.tag(9, WireType.Varint).bool(message.retractionEnabled);
        /* bool jet_mode_enabled = 10; */
        if (message.jetModeEnabled !== false)
            writer.tag(10, WireType.Varint).bool(message.jetModeEnabled);
        /* uint32 thruster_position = 8; */
        if (message.thrusterPosition !== 0)
            writer.tag(8, WireType.Varint).uint32(message.thrusterPosition);
        /* MotorStatus motor_status = 5; */
        if (message.motorStatus)
            MotorStatus.internalBinaryWrite(message.motorStatus, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* ChargerStatus charger_status = 6; */
        if (message.chargerStatus)
            ChargerStatus.internalBinaryWrite(message.chargerStatus, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* Versions versions = 7; */
        if (message.versions)
            Versions.internalBinaryWrite(message.versions, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AtccmStatus
 */
export const AtccmStatus = new AtccmStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Values$Type extends MessageType<Values> {
    constructor() {
        super("Values", [
            { no: 1, name: "termination_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "charger_on", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "blinks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "thruster_position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "retraction_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "jet_mode_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Values>): Values {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminationEnabled = false;
        message.chargerOn = false;
        message.blinks = 0;
        message.thrusterPosition = 0;
        message.retractionEnabled = false;
        message.jetModeEnabled = false;
        if (value !== undefined)
            reflectionMergePartial<Values>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Values): Values {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool termination_enabled */ 1:
                    message.terminationEnabled = reader.bool();
                    break;
                case /* bool charger_on */ 2:
                    message.chargerOn = reader.bool();
                    break;
                case /* uint32 blinks */ 3:
                    message.blinks = reader.uint32();
                    break;
                case /* uint32 thruster_position */ 4:
                    message.thrusterPosition = reader.uint32();
                    break;
                case /* bool retraction_enabled */ 5:
                    message.retractionEnabled = reader.bool();
                    break;
                case /* bool jet_mode_enabled */ 6:
                    message.jetModeEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Values, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool termination_enabled = 1; */
        if (message.terminationEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.terminationEnabled);
        /* bool charger_on = 2; */
        if (message.chargerOn !== false)
            writer.tag(2, WireType.Varint).bool(message.chargerOn);
        /* uint32 blinks = 3; */
        if (message.blinks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.blinks);
        /* uint32 thruster_position = 4; */
        if (message.thrusterPosition !== 0)
            writer.tag(4, WireType.Varint).uint32(message.thrusterPosition);
        /* bool retraction_enabled = 5; */
        if (message.retractionEnabled !== false)
            writer.tag(5, WireType.Varint).bool(message.retractionEnabled);
        /* bool jet_mode_enabled = 6; */
        if (message.jetModeEnabled !== false)
            writer.tag(6, WireType.Varint).bool(message.jetModeEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Values
 */
export const Values = new Values$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Configuration$Type extends MessageType<Configuration> {
    constructor() {
        super("Configuration", [
            { no: 1, name: "termination_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "charger_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "thruster_position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "retraction_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "jet_mode_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "inactivityShutdownEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "inactivityShutdownTimeoutIsSeconds", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Configuration>): Configuration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminationEnabled = false;
        message.chargerEnabled = false;
        message.thrusterPosition = 0;
        message.retractionEnabled = false;
        message.jetModeEnabled = false;
        message.inactivityShutdownEnabled = false;
        message.inactivityShutdownTimeoutIsSeconds = 0;
        if (value !== undefined)
            reflectionMergePartial<Configuration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Configuration): Configuration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool termination_enabled */ 1:
                    message.terminationEnabled = reader.bool();
                    break;
                case /* bool charger_enabled */ 2:
                    message.chargerEnabled = reader.bool();
                    break;
                case /* uint32 thruster_position */ 3:
                    message.thrusterPosition = reader.uint32();
                    break;
                case /* bool retraction_enabled */ 4:
                    message.retractionEnabled = reader.bool();
                    break;
                case /* bool jet_mode_enabled */ 5:
                    message.jetModeEnabled = reader.bool();
                    break;
                case /* bool inactivityShutdownEnabled */ 6:
                    message.inactivityShutdownEnabled = reader.bool();
                    break;
                case /* uint32 inactivityShutdownTimeoutIsSeconds */ 7:
                    message.inactivityShutdownTimeoutIsSeconds = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Configuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool termination_enabled = 1; */
        if (message.terminationEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.terminationEnabled);
        /* bool charger_enabled = 2; */
        if (message.chargerEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.chargerEnabled);
        /* uint32 thruster_position = 3; */
        if (message.thrusterPosition !== 0)
            writer.tag(3, WireType.Varint).uint32(message.thrusterPosition);
        /* bool retraction_enabled = 4; */
        if (message.retractionEnabled !== false)
            writer.tag(4, WireType.Varint).bool(message.retractionEnabled);
        /* bool jet_mode_enabled = 5; */
        if (message.jetModeEnabled !== false)
            writer.tag(5, WireType.Varint).bool(message.jetModeEnabled);
        /* bool inactivityShutdownEnabled = 6; */
        if (message.inactivityShutdownEnabled !== false)
            writer.tag(6, WireType.Varint).bool(message.inactivityShutdownEnabled);
        /* uint32 inactivityShutdownTimeoutIsSeconds = 7; */
        if (message.inactivityShutdownTimeoutIsSeconds !== 0)
            writer.tag(7, WireType.Varint).uint32(message.inactivityShutdownTimeoutIsSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Configuration
 */
export const Configuration = new Configuration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AtccmPacket$Type extends MessageType<AtccmPacket> {
    constructor() {
        super("AtccmPacket", [
            { no: 1, name: "protocol_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "command", kind: "enum", T: () => ["Command", Command] },
            { no: 3, name: "write", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "status", kind: "message", T: () => AtccmStatus },
            { no: 5, name: "values", kind: "message", T: () => Values },
            { no: 6, name: "configuration", kind: "message", T: () => Configuration }
        ]);
    }
    create(value?: PartialMessage<AtccmPacket>): AtccmPacket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocolVersion = 0;
        message.command = 0;
        message.write = false;
        if (value !== undefined)
            reflectionMergePartial<AtccmPacket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AtccmPacket): AtccmPacket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 protocol_version */ 1:
                    message.protocolVersion = reader.uint32();
                    break;
                case /* Command command */ 2:
                    message.command = reader.int32();
                    break;
                case /* bool write */ 3:
                    message.write = reader.bool();
                    break;
                case /* AtccmStatus status */ 4:
                    message.status = AtccmStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* Values values */ 5:
                    message.values = Values.internalBinaryRead(reader, reader.uint32(), options, message.values);
                    break;
                case /* Configuration configuration */ 6:
                    message.configuration = Configuration.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AtccmPacket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 protocol_version = 1; */
        if (message.protocolVersion !== 0)
            writer.tag(1, WireType.Varint).uint32(message.protocolVersion);
        /* Command command = 2; */
        if (message.command !== 0)
            writer.tag(2, WireType.Varint).int32(message.command);
        /* bool write = 3; */
        if (message.write !== false)
            writer.tag(3, WireType.Varint).bool(message.write);
        /* AtccmStatus status = 4; */
        if (message.status)
            AtccmStatus.internalBinaryWrite(message.status, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Values values = 5; */
        if (message.values)
            Values.internalBinaryWrite(message.values, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* Configuration configuration = 6; */
        if (message.configuration)
            Configuration.internalBinaryWrite(message.configuration, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AtccmPacket
 */
export const AtccmPacket = new AtccmPacket$Type();
